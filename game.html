<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Escape the SCP — 3D (Daytime)</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      background: #dcebf6;
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial;
    }

    #app {
      height: 100%;
      width: 100%;
      position: relative;
      overflow: hidden
    }

    #menu {
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  z-index: 30;

  /* New background image */
  background: url("main-menu-bg.jpg") no-repeat center center;
  background-size: cover;
}


    .menu-inner {
      background: rgba(255, 255, 255, 0.85);
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .15);
      text-align: center
    }

    .title {
      font-size: 28px;
      font-weight: 800;
      margin-bottom: 8px
    }

    .btn {
      padding: 10px 16px;
      border-radius: 10px;
      border: 0;
      background: #0f172a;
      color: #fff;
      font-weight: 700;
      cursor: pointer
    }

    #stage {
      position: absolute;
      inset: 0;
      display: none
    }

    #hud {
      position: absolute;
      left: 12px;
      top: 12px;
      z-index: 25;
      background: rgba(255, 255, 255, .9);
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 700
    }

    #useBtn {
      position: absolute;
      left: 50%;
      bottom: 50%;
      /* a bit above bottom edge */
      transform: translateX(-50%);
      z-index: 999;
      padding: 16px 24px;
      font-size: 14px;
      border-radius: 10px;
      background: #0f172a;
      color: #fff;
      display: none;
    }


    .controls {
      position: absolute;
      right: 10px;
      bottom: 10px;
      display: grid;
      grid-template-columns: repeat(3, 56px);
      grid-template-rows: repeat(3, 56px);
      gap: 6px;
      z-index: 25
    }

    .controls button {
      border-radius: 12px;
      border: 0;
      background: rgba(15, 23, 42, .85);
      color: #fff;
      font-weight: 800
    }

    #pl-notice {
      position: absolute;
      left: 50%;
      top: 10px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      z-index: 50;
      display: none
    }

    canvas {
      display: block
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.15);
      }
    }

    #useBtn.emergency {
      animation: pulse 0.8s infinite;
      font-weight: 900;
      text-transform: uppercase;
      border: 3px solid red;
      box-shadow: 0 0 15px red;
    }

    #introMsg {
      position: absolute;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 22px;
      font-weight: bold;
      text-align: center;
      opacity: 0;
      transition: opacity 1s ease;
      pointer-events: none;
      /* prevent blocking input */
    }

    #introMsg.show {
      opacity: 1;
    }

    .inline-icon {
      height: 1em;
      width: auto;
      vertical-align: middle;
    }
  </style>
</head>

<body>
  <div id="app">
    <section id="menu">
      <div class="menu-inner">
        <div class="title">Stop The Abusive Gaigond</div>
        <button class="btn" id="startBtn">Start</button>
      </div>
    </section>

    <section id="stage">
      <div id="hud">Maze <strong id="mazeNum">#1</strong> • Status: <strong id="status">READY</strong></div>
      <button id="useBtn">PRESS (E)</button>
      <div id="buttonLabel"></div>
      <div id="pl-notice"></div>
    </section>

    <section id="overlay" style="display:none">
      <div class="menu-inner" id="resultCard">
        <h2 id="resultTitle">You Escaped!</h2>
        <p id="resultText" style="color:#475569">...</p>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:10px">
          <button class="btn" id="againBtn">Play Again</button>
          <button class="btn" id="menuBtn">Main Menu</button>
        </div>
      </div>
    </section>

    <!-- Pause Hint -->
    <div id="pauseHint"
      style="position: absolute; top: 10px; right: 10px; color: white; font-family: monospace; font-size: 14px;">
      Press P to Pause
    </div>
    <!-- Pause Menu -->
    <div id="pauseMenu" style="display:none; position: absolute; top: 50%; left: 50%; 
    transform: translate(-50%, -50%); background: silver; padding: 20px; 
    border-radius: 10px; text-align: center; color: rgb(0, 0, 0); font-family: monospace; z-index: 1000;">
      <h2>Paused</h2>
      <button id="continueBtn" class="btn">Continue</button>
      <button id="mainMenuBtn" class="btn">Main Menu</button>
    </div>

    <div id="introMsg">
      Find and Press the
      <img src="button.jpg" alt="button" class="inline-icon">
      Before Gaigond catches you.
    </div>

  </div>

  <audio id="scpSound" src="chase-audio.mp3" loop></audio>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    (() => {
      // ---------- CONFIG ----------
      const CONFIG = {
        GRID_W: 11, GRID_H: 9, CELL: 3.4, WALL_H: 2.8,
        PLAYER_STEP_MS: 400, SCP_STEP_MS: 490, PATH_RECALC_MS: 590,
        MAX_HEAR_DIST: 6,
        PICTURE_SRC: 'https://raw.githubusercontent.com/ankito090/My-SCP-Game/main/gaigond.jpg',
      };

      // DOM
      const menu = document.getElementById('menu');
      const startBtn = document.getElementById('startBtn');
      const stage = document.getElementById('stage');
      const hud = document.getElementById('hud');
      const statusEl = document.getElementById('status');
      const mazeNumEl = document.getElementById('mazeNum');
      const overlay = document.getElementById('overlay');
      const resultTitle = document.getElementById('resultTitle');
      const resultText = document.getElementById('resultText');
      const againBtn = document.getElementById('againBtn');
      const menuBtn = document.getElementById('menuBtn');
      const useBtn = document.getElementById('useBtn');
      const buttonLabel = document.getElementById('buttonLabel');
      const plNotice = document.getElementById('pl-notice');

      // Audio placeholders (replace with real URLs/base64 as needed)
      // Audio placeholders (replace with real URLs/base64 as needed)
      // Try to use the <audio id="scpSound"> if it exists, otherwise fall back to a new Audio()
      let chaseAudio = document.getElementById('scpSound');
      if (!chaseAudio) {
        // Audio element not yet in DOM — create a fallback Audio object so script doesn't crash
        chaseAudio = new Audio();
        chaseAudio.loop = true;
      }
      chaseAudio.volume = 0;

      const winAudio = new Audio("win-audio.mp3");
      const lossAudio = new Audio("loss-audio.mp3");
      winAudio.volume = 0.5;   // a bit softer
      lossAudio.volume = 0.7;


      // Maze generation (recursive backtracker)
      const DIRS = [[0, -1, 'N'], [1, 0, 'E'], [0, 1, 'S'], [-1, 0, 'W']];
      const OPP = { N: 'S', S: 'N', E: 'W', W: 'E' };
      let seed = Math.floor(Math.random() * 1e9);
      function rand() { seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5; return (seed >>> 0) / 4294967296; }

      function genMaze(W, H) {
        const grid = Array.from({ length: H }, () => Array.from({ length: W }, () => ({ N: true, E: true, S: true, W: true, vis: false })));
        const stack = []; const s = [Math.floor(rand() * W), Math.floor(rand() * H)];
        stack.push(s); grid[s[1]][s[0]].vis = true;
        while (stack.length) {
          const [cx, cy] = stack[stack.length - 1];
          const dirs = DIRS.slice().sort(() => rand() - .5);
          let moved = false;
          for (const [dx, dy, dk] of dirs) {
            const nx = cx + dx, ny = cy + dy; if (nx < 0 || ny < 0 || nx >= W || ny >= H) continue;
            if (!grid[ny][nx].vis) {
              grid[cy][cx][dk] = false; grid[ny][nx][OPP[dk]] = false;
              grid[ny][nx].vis = true; stack.push([nx, ny]); moved = true; break;
            }
          }
          if (!moved) stack.pop();
        }
        return grid;
      }


      // THREE scene
      let scene, camera, renderer;
      let walls = [], floorMesh = null, scpMesh = null, goalMesh = null;
      let GRID_W, GRID_H, grid, C;
      let running = false, state = 'menu', mazeCount = 0, pathTimer = null;
      let paused = false;

      const player = { x: 0, y: 0, moving: false, from: [0, 0], to: [0, 0], start: 0, yaw: 0 };
      const scp = { x: 0, y: 0, moving: false, from: [0, 0], to: [0, 0], start: 0, path: [] };
      const goal = { x: 0, y: 0 }; // <-- FIX: define goal to avoid ReferenceError

      // input
      const keys = { KeyW: 0, KeyA: 0, KeyS: 0, KeyD: 0, KeyE: 0 };
      window.addEventListener('keydown', e => { if (keys[e.code] !== undefined) { keys[e.code] = 1; e.preventDefault(); } });
      window.addEventListener('keyup', e => { if (keys[e.code] !== undefined) { keys[e.code] = 0; e.preventDefault(); } });
      // ESC to pause/resume
      window.addEventListener('keydown', (e) => {
        if (e.code !== 'KeyP') return;
        e.preventDefault();

        if (state === 'run') {
          // release mouse so the pause UI can be clicked
          if (document.pointerLockElement) document.exitPointerLock();
          pauseGame();      // <- from Step 3
        } else if (state === 'paused') {
          resumeGame();     // <- from Step 3
        }
      });

      useBtn.addEventListener('click', () => { tryUse() });

      // --- WASD relative-to-look helpers ---
      // Facing index based on yaw: 0=up(N), 1=left(W), 2=down(S), 3=right(E)
      function facingIndex() {
        const TWO_PI = Math.PI * 2;
        let ang = player.yaw % TWO_PI; if (ang < 0) ang += TWO_PI; // normalize to [0, 2π)
        return Math.floor((ang + Math.PI / 4) / (Math.PI / 2)) % 4; // quantize to 4 cardinals
      }
      function forwardDir() { const map = ['up', 'left', 'down', 'right']; return map[facingIndex()]; }
      function leftDir() { const map = ['up', 'left', 'down', 'right']; return map[(facingIndex() + 1) % 4]; }
      function backDir() { const map = ['up', 'left', 'down', 'right']; return map[(facingIndex() + 2) % 4]; }
      function rightDir() { const map = ['up', 'left', 'down', 'right']; return map[(facingIndex() + 3) % 4]; }

      // Lightweight self-tests (won't break gameplay if they fail)
      (function __sanityTests() {
        console.assert(goal && typeof goal.x === 'number' && typeof goal.y === 'number', 'Goal object is missing or malformed');
        const y0 = player.yaw;
        player.yaw = 0; console.assert(forwardDir() === 'up' && rightDir() === 'right' && leftDir() === 'left' && backDir() === 'down', 'Yaw 0 mapping failed');
        player.yaw = Math.PI / 2; console.assert(forwardDir() === 'left' && rightDir() === 'up' && backDir() === 'right' && leftDir() === 'down', 'Yaw π/2 mapping failed');
        player.yaw = Math.PI; console.assert(forwardDir() === 'down', 'Yaw π mapping failed');
        player.yaw = -Math.PI / 2; console.assert(forwardDir() === 'right', 'Yaw -π/2 mapping failed');
        player.yaw = y0;
      })();

      function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color("#11111a"); // dark but not pitch black

        // camera
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('stage').appendChild(renderer.domElement);

        // ambient sky/ground glow
        const hemi = new THREE.HemisphereLight(0x445566, 0x222222, 0.8);
        scene.add(hemi);

        // moonlight (directional)
        const moon = new THREE.DirectionalLight(0xaaccff, 1.2);
        moon.position.set(15, 30, 15);
        moon.castShadow = true;
        scene.add(moon);

        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        })

        // pointer lock (safe): may be blocked in sandbox; fallback to drag-look
        renderer.domElement.addEventListener('click', () => {
          if (state === 'run' && document.pointerLockElement !== renderer.domElement) {
            try { renderer.domElement.requestPointerLock?.(); }
            catch (err) { plNotice.style.display = 'block'; plNotice.textContent = 'Pointer lock blocked. Use drag-to-look or open in a new tab with allow-pointer-lock.'; }
          }
        });

        // mouse look (pointer lock) + drag fallback
        let dragging = false, lastX = 0;
        document.addEventListener('mousemove', (e) => {
          if (state !== 'run') return;
          if (document.pointerLockElement === renderer.domElement) { player.yaw -= e.movementX * 0.0025; }
          else if (dragging) { const dx = e.clientX - lastX; lastX = e.clientX; player.yaw -= dx * 0.0025; }
        });
        renderer.domElement.addEventListener('mousedown', (e) => { if (state === 'run') { dragging = true; lastX = e.clientX; } });
        document.addEventListener('mouseup', () => { dragging = false; });
      }


      // build maze meshes visible in daytime
      function buildMaze() {
        // clear
        for (const m of walls) scene.remove(m); walls = [];
        if (floorMesh) scene.remove(floorMesh);
        if (scpMesh) scene.remove(scpMesh);
        if (goalMesh) scene.remove(goalMesh);

        C = CONFIG.CELL;
        const wallH = CONFIG.WALL_H;

        // floor: lighter slate gray
        const floorGeo = new THREE.PlaneGeometry(GRID_W * C, GRID_H * C);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
        floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.set(GRID_W * C / 2 - C / 2, 0, GRID_H * C / 2 - C / 2);
        scene.add(floorMesh);

        // walls: lighter bluish gray
        const wallColor = 0x3b4b5f;
        const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.85 });
        for (let y = 0; y < GRID_H; y++) {
          for (let x = 0; x < GRID_W; x++) {
            const cell = grid[y][x];
            const cx = x * C, cz = y * C;
            if (cell.N) { const g = new THREE.BoxGeometry(C, wallH, 0.12); const m = new THREE.Mesh(g, wallMat); m.position.set(cx, wallH / 2, cz - C / 2); scene.add(m); walls.push(m); }
            if (cell.S) { const g = new THREE.BoxGeometry(C, wallH, 0.12); const m = new THREE.Mesh(g, wallMat); m.position.set(cx, wallH / 2, cz + C / 2); scene.add(m); walls.push(m); }
            if (cell.W) { const g = new THREE.BoxGeometry(0.12, wallH, C); const m = new THREE.Mesh(g, wallMat); m.position.set(cx - C / 2, wallH / 2, cz); scene.add(m); walls.push(m); }
            if (cell.E) { const g = new THREE.BoxGeometry(0.12, wallH, C); const m = new THREE.Mesh(g, wallMat); m.position.set(cx + C / 2, wallH / 2, cz); scene.add(m); walls.push(m); }
          }
        }

        // Goal pillar + glowing cyan button
        const pillar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.35, 0.35, 0.6, 16),
          new THREE.MeshStandardMaterial({ color: 0x0f766e, roughness: 0.8 })
        );
        const btn = new THREE.Mesh(
          new THREE.CylinderGeometry(0.22, 0.22, 0.12, 16),
          new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00cccc, emissiveIntensity: 1.5 })
        );
        pillar.add(btn); btn.position.y = 0.36;
        goalMesh = new THREE.Group(); goalMesh.add(pillar); scene.add(goalMesh);

        // SCP billboard
        scpMesh = new THREE.Group();
        scpMesh.name = 'scpMesh';

        const scpMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          side: THREE.DoubleSide
        });

        const scpPlane = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.6), scpMaterial);
        scpPlane.position.set(0, 0.8, 0);
        scpPlane.rotation.y = Math.PI;
        scpMesh.add(scpPlane);

        new THREE.TextureLoader().load(
          CONFIG.PICTURE_SRC,
          (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.x = -1;
            scpPlane.material.map = texture;
            scpPlane.material.needsUpdate = true;
          },
          undefined,
          (err) => {
            console.warn('SCP texture failed to load:', CONFIG.PICTURE_SRC, err);
            scpPlane.material.color.set(0xff0000);
          }
        );
        
        scene.add(scpMesh);

      }




      // convert cell->world center
      function cellToWorld(cx, cy) {
        return new THREE.Vector3(cx * C, 0, cy * C);
      }

      // place entities (spreaded)
      function placeEntities() {
        // pick only valid walkable cells (grid[y][x] === 0)
        function rcell() {
          let x, y;
          do {
            x = Math.floor(rand() * GRID_W);
            y = Math.floor(rand() * GRID_H);
          } while (grid[y][x] === 1); // avoid walls
          return [x, y];
        }

        let px, py, gx, gy, sx, sy;

        // --- Player spawn
        [px, py] = rcell();

        // --- Goal spawn (not too close to player)
        do {
          [gx, gy] = rcell();
        } while (Math.abs(gx - px) + Math.abs(gy - py) < (GRID_W + GRID_H) / 4);

        // --- BFS to find all reachable cells from player
        function bfsReachable(startX, startY) {
          const visited = new Set();
          const q = [[startX, startY]];
          visited.add(startX + "," + startY);

          while (q.length) {
            const [cx, cy] = q.shift();
            const neighbors = [
              [cx + 1, cy],
              [cx - 1, cy],
              [cx, cy + 1],
              [cx, cy - 1]
            ];
            for (const [nx, ny] of neighbors) {
              if (nx < 0 || ny < 0 || nx >= GRID_W || ny >= GRID_H) continue;
              if (grid[ny][nx] === 1) continue; // wall
              const key = nx + "," + ny;
              if (!visited.has(key)) {
                visited.add(key);
                q.push([nx, ny]);
              }
            }
          }
          return Array.from(visited).map(s => s.split(",").map(Number));
        }

        const reachableCells = bfsReachable(px, py);

        // Pick SCP only from reachable cells
        let validCells = reachableCells.filter(([x, y]) => {
          return (
            (Math.abs(x - px) + Math.abs(y - py) >= (GRID_W + GRID_H) / 4) &&
            !(x === gx && y === gy)
          );
        });
        if (validCells.length === 0) validCells = reachableCells; // fallback

        [sx, sy] = validCells[Math.floor(Math.random() * validCells.length)];

        // Debug info
        console.log("📍 Player:", px, py, "Goal:", gx, gy, "SCP:", sx, sy, "Reachable cells:", reachableCells.length);

        // --- Assign positions
        player.x = px;
        player.y = py;
        player.from = [px, py];
        player.to = [px, py];
        player.yaw = 0;
        const ppos = cellToWorld(px, py);
        camera.position.set(ppos.x, 1.6, ppos.z);

        goal.x = gx;
        goal.y = gy;
        const gpos = cellToWorld(gx, gy);
        goalMesh.position.set(gpos.x, 0.35, gpos.z);

        scp.x = sx;
        scp.y = sy;
        const spos = cellToWorld(sx, sy);
        scpMesh.position.set(spos.x, 0.8, spos.z);
      }






      // attempt tile step from UI or keys
      function attemptStep(dir) {
        if (player.moving || state !== 'run') return;
        const cell = grid[player.y][player.x];
        let nx = player.x, ny = player.y;
        if (dir === 'up' && !cell.N) ny--;
        else if (dir === 'down' && !cell.S) ny++;
        else if (dir === 'left' && !cell.W) nx--;
        else if (dir === 'right' && !cell.E) nx++;
        if (nx === player.x && ny === player.y) return;
        player.from = [player.x, player.y]; player.to = [nx, ny]; player.start = performance.now(); player.moving = true;
      }

      // keyboard-based mapping: W/A/S/D relative to camera yaw
      function handleKeyboardInput() {
        if (player.moving) return;
        let want = null;
        if (keys.KeyW) want = forwardDir();
        else if (keys.KeyS) want = backDir();
        else if (keys.KeyA) want = leftDir();
        else if (keys.KeyD) want = rightDir();
        if (want) attemptStep(want);
        if (keys.KeyE) tryUse();
      }

      // update player interpolation
      function updatePlayer() {
        if (player.moving) {
          const t = (performance.now() - player.start) / CONFIG.PLAYER_STEP_MS;
          if (t >= 1) { player.x = player.to[0]; player.y = player.to[1]; player.moving = false; }
          const ax = THREE.MathUtils.lerp(player.from[0], player.to[0], Math.min(1, t));
          const ay = THREE.MathUtils.lerp(player.from[1], player.to[1], Math.min(1, t));
          const pos = cellToWorld(ax, ay);
          camera.position.x = pos.x; camera.position.z = pos.z;
        }
        // apply yaw (mouse/drag/touch look)
        camera.rotation.y = player.yaw;
      }

      function updateSCP() {
        if (!(scp.path && scp.path.length)) return;

        // Ensure no duplicate steps in the path
        while (scp.path.length > 0 && scp.path[0][0] === scp.x && scp.path[0][1] === scp.y) {
          console.log(`⚠️ [SKIP] Removing duplicate waypoint (${scp.path[0][0]}, ${scp.path[0][1]})`);
          scp.path.shift();
        }
        if (scp.path.length === 0) return;

        let t = (performance.now() - scp.start) / CONFIG.SCP_STEP_MS;

        if (!scp.moving) {
          const next = scp.path.shift();
          if (!next) return;

          console.log(`👣 [INIT] SCP starts moving from (${scp.x}, ${scp.y}) → (${next[0]}, ${next[1]}) | Remaining path: ${scp.path.length}`);

          scp.from = [scp.x, scp.y];
          scp.to = [next[0], next[1]];
          scp.start = performance.now();
          scp.moving = true;
          t = 0;
        }

        // Handle multiple steps in a single frame if needed
        while (t >= 1 && scp.moving) {
          scp.x = scp.to[0];
          scp.y = scp.to[1];
          console.log(`✅ [ARRIVE] SCP reached (${scp.x}, ${scp.y})`);

          // Skip duplicates again
          while (scp.path.length > 0 && scp.path[0][0] === scp.x && scp.path[0][1] === scp.y) {
            console.log(`⚠️ [SKIP] Removing duplicate waypoint (${scp.path[0][0]}, ${scp.path[0][1]})`);
            scp.path.shift();
          }

          if (scp.path.length > 0) {
            const next = scp.path.shift();
            console.log(`👣 [CHAIN] SCP continues from (${scp.x}, ${scp.y}) → (${next[0]}, ${next[1]}) | Remaining path: ${scp.path.length}`);

            scp.from = [scp.x, scp.y];
            scp.to = [next[0], next[1]];
            scp.start = performance.now();
            t = (performance.now() - scp.start) / CONFIG.SCP_STEP_MS;
          } else {
            scp.moving = false;
            break;
          }
        }

        if (scp.moving) {
          const ax = THREE.MathUtils.lerp(scp.from[0], scp.to[0], Math.min(1, t));
          const ay = THREE.MathUtils.lerp(scp.from[1], scp.to[1], Math.min(1, t));
          const pos = cellToWorld(ax, ay);
          scpMesh.position.x = pos.x;
          scpMesh.position.z = pos.z;

          console.log(`➡️ [MOVE] Interpolating between (${scp.from[0]}, ${scp.from[1]}) → (${scp.to[0]}, ${scp.to[1]}) | t=${t.toFixed(2)}`);
        }

        // === 🔥 Billboard Effect (face the player without using playerMesh) ===
        // Compute player's world position and keep Y at the SCP's current Y to avoid tilting.
        const playerWorld = cellToWorld(player.x, player.y);
        const lookTarget = new THREE.Vector3(playerWorld.x, scpMesh.position.y, playerWorld.z);
        scpMesh.lookAt(lookTarget);

        // Debug: show yaw (rotation around Y axis) and the target cell
        const yaw = scpMesh.rotation.y;
        console.log(`🧭 [BILLBOARD] Yaw=${yaw.toFixed(3)} → player at (${player.x}, ${player.y})`);

        if (player.x === scp.x && player.y === scp.y) {
          console.log("💀 SCP caught the player!");
          triggerJumpscare();   // 🔥 instead of endGame(false)
        }
      }





      function recalcSCPPath() {
        scp.path = bfs([scp.x, scp.y], [player.x, player.y]);
      }

      // recompute path periodically
      function startPathTimer() {
        if (pathTimer) clearInterval(pathTimer);
        pathTimer = setInterval(() => {
          if (state !== 'run') return;
          const p = astar(grid, scp.x, scp.y, player.x, player.y);
          scp.path = p ? p.slice(1) : [];
        }, CONFIG.PATH_RECALC_MS);
      }

      function updateChaseAudio() {
        const dx = player.x - scp.x;
        const dy = player.y - scp.y;
        const d = Math.sqrt(dx * dx + dy * dy);

        if (d >= CONFIG.MAX_HEAR_DIST) {
          chaseAudio.volume = 0; // completely silent beyond max distance
          return;
        }

        const normDist = d / CONFIG.MAX_HEAR_DIST;
        const vol = Math.exp(-4 * normDist);
        chaseAudio.volume = Math.max(0, Math.min(1, vol));
      }




      function tryUse() {
        if (player.x === goal.x && player.y === goal.y) endGame(true);
      }

      function endGame(win) {
        useBtn.style.display = 'none';
        useBtn.classList.remove('emergency');
        state = 'over';
        running = false;

        try { chaseAudio.pause(); } catch (e) { }

        // stop any existing win/loss audio before replaying
        try {
          winAudio.pause();
          winAudio.currentTime = 0;
          lossAudio.pause();
          lossAudio.currentTime = 0;
        } catch (e) { }

        // play win or loss sound
        if (win) {
          winAudio.play().catch(() => { });
        } else {
          lossAudio.play().catch(() => { });
        }

        // 🔑 Release the mouse so hover/click works
        if (document.exitPointerLock) {
          document.exitPointerLock();
        }

        resultTitle.textContent = win ? 'You Won!' : 'You Were Caught!';
        resultText.textContent = win ?
          'You stopped Gaigond from abusing you any further.' :
          'Gaigond caught you and abused you to dead.';
        overlay.style.display = 'grid';
        statusEl.textContent = win ? 'WIN' : 'LOSS';
      }

      function showIntroMessage() {
        const msg = document.getElementById('introMsg');
        msg.classList.add('show');
        setTimeout(() => {
          msg.classList.remove('show');
        }, 3000); // visible for 3 seconds
      }


      function triggerJumpscare() {
        if (window.__jumpScareActive) return;
        window.__jumpScareActive = true;

        const cam = camera;
        const scpPos = scpMesh.position.clone();

        // Disable player controls during jumpscare
        const hadControls = typeof controls !== "undefined" && controls;
        const prevControlsEnabled = hadControls ? controls.enabled : null;
        if (hadControls) controls.enabled = false;

        // Save original states
        const saved = {
          fov: cam.fov,
          scpScale: scpMesh.scale.clone()
        };

        // Compute direction from player → SCP
        const playerPos = cellToWorld(player.x, player.y);
        const targetDir = scpPos.clone().sub(playerPos).setY(0).normalize();

        // Rotate player to face SCP (fixes "doesn’t look at SCP" issue)
        if (hadControls && controls.getObject) {
          const targetYaw = Math.atan2(targetDir.x, targetDir.z);
          controls.getObject().rotation.y = targetYaw;
        }

        // Animation settings
        const duration = 500; // 1s
        const start = performance.now();

        function easeInOutCubic(t) {
          return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function frame(now) {
          const t = Math.min(1, (now - start) / duration);
          const k = easeInOutCubic(t);

          // Zoom effect
          cam.fov = THREE.MathUtils.lerp(saved.fov, 40, k);
          cam.updateProjectionMatrix();

          // SCP grows larger
          const scale = THREE.MathUtils.lerp(1, 1.5, k);
          scpMesh.scale.set(
            saved.scpScale.x * scale,
            saved.scpScale.y * scale,
            saved.scpScale.z * scale
          );

          // Camera shake (subtle)
          const shake = (1 - t) * 0.15;
          cam.position.x += (Math.random() - 0.5) * shake;
          cam.position.y += (Math.random() - 0.5) * shake * 0.5;
          cam.position.z += (Math.random() - 0.5) * shake;

          if (t < 1) {
            requestAnimationFrame(frame);
          } else {
            // Reset
            cam.fov = saved.fov;
            cam.updateProjectionMatrix();
            scpMesh.scale.copy(saved.scpScale);

            // Restore controls (fixes mouse inverted issue)
            if (hadControls) controls.enabled = prevControlsEnabled;

            window.__jumpScareActive = false;

            // End game
            endGame(false);
          }
        }

        requestAnimationFrame(frame);
      }




      // render loop
      function animate() {
        if (!running) return;
        requestAnimationFrame(animate);

        // When not in the running state, render a static frame but skip updates.
        if (state !== 'run') {
          renderer.render(scene, camera);
          return;
        }

        handleKeyboardInput();
        updatePlayer();
        updateSCP();
        updateChaseAudio();
        updateButtonLabel();
        renderer.render(scene, camera);
      }


      function updateButtonLabel() {
        if (state !== 'run') { buttonLabel.style.display = 'none'; return; }
        const vec = cellToWorld(goal.x, goal.y).clone(); vec.y = 0.65; vec.project(camera);
        const sx = (vec.x * 0.5 + 0.5) * window.innerWidth, sy = (-vec.y * 0.5 + 0.5) * window.innerHeight;
        if (vec.z > 1 || vec.z < -1) { buttonLabel.style.display = 'none'; } else {
          buttonLabel.style.display = 'block';
          //buttonLabel.textContent = CONFIG.BUTTON_LABEL;
          buttonLabel.style.left = Math.round(sx - buttonLabel.offsetWidth / 2) + 'px';
          buttonLabel.style.top = Math.round(sy - 30) + 'px';
        }
        if (player.x === goal.x && player.y === goal.y) {
          useBtn.style.display = 'block';
          useBtn.classList.add('emergency');
        } else {
          useBtn.style.display = 'none';
          useBtn.classList.remove('emergency');
        }
      }

      // --- Fixed A* for cell objects with walls ---
      function astar(grid, sx, sy, gx, gy) {
        const open = [[sx, sy]];
        const cameFrom = {};
        const gScore = {};
        const fScore = {};

        function key(x, y) { return `${x},${y}`; }
        function heuristic(x, y) { return Math.abs(x - gx) + Math.abs(y - gy); }

        gScore[key(sx, sy)] = 0;
        fScore[key(sx, sy)] = heuristic(sx, sy);

        while (open.length > 0) {
          // pick lowest fScore
          let currentIndex = 0;
          for (let i = 1; i < open.length; i++) {
            if (fScore[key(open[i][0], open[i][1])] < fScore[key(open[currentIndex][0], open[currentIndex][1])]) {
              currentIndex = i;
            }
          }

          const [cx, cy] = open.splice(currentIndex, 1)[0];

          if (cx === gx && cy === gy) {
            const path = [[cx, cy]];
            let k = key(cx, cy);
            while (cameFrom[k]) {
              const [px, py] = cameFrom[k];
              path.unshift([px, py]);
              k = key(px, py);
            }
            return path;
          }

          const neighbors = [];
          const cell = grid[cy][cx];

          if (!cell.N) neighbors.push([cx, cy - 1]);
          if (!cell.S) neighbors.push([cx, cy + 1]);
          if (!cell.W) neighbors.push([cx - 1, cy]);
          if (!cell.E) neighbors.push([cx + 1, cy]);

          for (const [nx, ny] of neighbors) {
            if (nx < 0 || ny < 0 || nx >= GRID_W || ny >= GRID_H) continue;

            const nk = key(nx, ny);
            const tentativeG = gScore[key(cx, cy)] + 1;

            if (gScore[nk] === undefined || tentativeG < gScore[nk]) {
              cameFrom[nk] = [cx, cy];
              gScore[nk] = tentativeG;
              fScore[nk] = tentativeG + heuristic(nx, ny);
              if (!open.some(([ox, oy]) => ox === nx && oy === ny)) {
                open.push([nx, ny]);
              }
            }
          }
        }

        return null; // no path
      }

      function pauseGame() {
        paused = true;
        state = 'paused'; // <-- use 'paused' (matches the ESC handler)
        document.getElementById("pauseMenu").style.display = "block";

        // optionally stop audio so pause feels complete
        try { chaseAudio.pause(); } catch (e) { }
      }

      function resumeGame() {
        paused = false;
        state = 'run';
        document.getElementById("pauseMenu").style.display = "none";

        // don't force pointer lock here (browser may block); player can click to re-lock
        try { chaseAudio.play().catch(() => { }); } catch (e) { }
      }


      // --- new game / setup ---
      function newGame() {
        // new seed, grid dims
        seed = Math.floor(Math.random() * 1e9);
        GRID_W = CONFIG.GRID_W;
        GRID_H = CONFIG.GRID_H;
        grid = genMaze(GRID_W, GRID_H);
        buildMaze();
        placeEntities();
        console.log("Testing A* from Player to Goal:", astar(grid, player.x, player.y, goal.x, goal.y));


        // --- Verify path from SCP to Player
        let p = astar(grid, scp.x, scp.y, player.x, player.y);
        if (!p) {
          console.warn("⚠️ No path at game start! Forcing SCP next to player.");
          // Force SCP to spawn beside player on a walkable tile
          const neighbors = [
            [player.x + 1, player.y],
            [player.x - 1, player.y],
            [player.x, player.y + 1],
            [player.x, player.y - 1]
          ];
          for (const [nx, ny] of neighbors) {
            if (nx >= 0 && ny >= 0 && nx < GRID_W && ny < GRID_H && grid[ny][nx] === 0) {
              scp.x = nx;
              scp.y = ny;
              const spos = cellToWorld(nx, ny);
              scpMesh.position.set(spos.x, 0.8, spos.z);
              break;
            }
          }
          p = astar(grid, scp.x, scp.y, player.x, player.y);
        }
        scp.path = p ? p.slice(1) : [];

        console.log("✅ Initial path length:", scp.path ? scp.path.length : "none");

        mazeCount++;
        mazeNumEl.textContent = '#' + mazeCount;
        statusEl.textContent = 'RUN';
        overlay.style.display = 'none';
        menu.style.display = 'none';
        stage.style.display = 'block';
        state = 'run';
        showIntroMessage();
        running = true;

        try {
          chaseAudio.currentTime = 0;   // rewind to start
          chaseAudio.play().catch(() => {
            // If autoplay blocked, ignore
          });
        } catch (e) { }

        startPathTimer();
        animate();
      }




      // --- UI wiring ---
      startBtn.addEventListener('click', () => {
        if (!scene) initThree();
        newGame();
      });
      againBtn.addEventListener('click', () => { overlay.style.display = 'none'; newGame(); });
      menuBtn.addEventListener('click', () => {
        overlay.style.display = 'none'; stage.style.display = 'none'; menu.style.display = 'grid';
        state = 'menu'; running = false; try { chaseAudio.pause(); } catch (e) { }
      });

      // Pause menu button handlers (inside IIFE so resumeGame(), menu, stage, overlay are in-scope)
      document.getElementById("continueBtn").addEventListener("click", () => {
        resumeGame();
      });

      document.getElementById("mainMenuBtn").addEventListener("click", () => {
        paused = false;
        state = 'menu';
        document.getElementById("pauseMenu").style.display = "none";
        overlay.style.display = 'none';
        stage.style.display = 'none';
        menu.style.display = 'grid';
        running = false;
        try { chaseAudio.pause(); } catch (e) { }
      });


      // mobile control buttons
    })();

  </script>
</body>

</html>